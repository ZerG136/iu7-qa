# Программирование. Подготовка к экзамену

## От автора

Куда скидывать найденные очепятки и печенюшки Вы, думаю, уже знаете:
- [t.me/zhikhkirill](https://t.me/zhikhkirill)
- [vk.com/zhikh.localhost](https://vk.com/zhikh.localhost)
- [github.com/zhikh23](https://github.com/zhikh23)

## Теоретические вопросы

- [Программирование. Подготовка к экзамену](#программирование-подготовка-к-экзамену)
  - [От автора](#от-автора)
  - [Теоретические вопросы](#теоретические-вопросы)
    - [1. Электронная вычислительная машина. Устройство ЭВМ. Программа. Исходный текст, исполняемый файл](#1-электронная-вычислительная-машина-устройство-эвм-программа-исходный-текст-исполняемый-файл)
      - [ЭВМ](#эвм)
      - [Устройство ЭВМ](#устройство-эвм)
      - [Программа и исходный текст](#программа-и-исходный-текст)
    - [2. Схемы алгоритмов](#2-схемы-алгоритмов)
      - [Нестрогое определение](#нестрогое-определение)
      - [Основные блоки](#основные-блоки)
    - [3. Языки программирования. Классификация](#3-языки-программирования-классификация)
      - [Язык программирования. Определение](#язык-программирования-определение)
      - [Классификация](#классификация)
    - [4. Язык Python. Структура программы. Лексемы языка](#4-язык-python-структура-программы-лексемы-языка)
      - [Язык программирования Python](#язык-программирования-python)
      - [Структура программы](#структура-программы)
      - [Лексемы языка Python](#лексемы-языка-python)
    - [5. Типы данных языка Python. Классификация. Скалярные типы данных. Приведение типов](#5-типы-данных-языка-python-классификация-скалярные-типы-данных-приведение-типов)
      - [Типы данных](#типы-данных)
      - [Классификация](#классификация-1)
      - [Типы данных](#типы-данных-1)
      - [Приведение типов](#приведение-типов)
    - [6. Операции над скалярными типами данных. Приоритеты операций](#6-операции-над-скалярными-типами-данных-приоритеты-операций)
      - [Над числами](#над-числами)
      - [Над логическими значениями](#над-логическими-значениями)
      - [Приоритеты операций](#приоритеты-операций)
    - [7. Функции ввода и вывода. Ввод данных](#7-функции-ввода-и-вывода-ввод-данных)
      - [Ввод](#ввод)
      - [Вывод](#вывод)
    - [8. Функции ввода и вывода. Функция вывода. Форматирование вывода](#8-функции-ввода-и-вывода-функция-вывода-форматирование-вывода)
      - [Форматирование вывода](#форматирование-вывода)
    - [9. Оператор присваивания. Множественное присваивание](#9-оператор-присваивания-множественное-присваивание)
      - [Оператор присваивания](#оператор-присваивания)
      - [Множественное присваивание](#множественное-присваивание)
      - [Комбинированное присваивание](#комбинированное-присваивание)
    - [10. Условный оператор. Полные условные операторы. Неполные условные операторы. Тернарный оператор условия. Примеры использования](#10-условный-оператор-полные-условные-операторы-неполные-условные-операторы-тернарный-оператор-условия-примеры-использования)
      - [Полный условный оператор](#полный-условный-оператор)
      - [Неполный условный оператор. Пример](#неполный-условный-оператор-пример)
      - [Тернарный оператор](#тернарный-оператор)
    - [11. Условные операторы. Множественный выбор. Вложенные операторы условия. Примеры использования](#11-условные-операторы-множественный-выбор-вложенные-операторы-условия-примеры-использования)
      - [Множественный выбор. Пример](#множественный-выбор-пример)
      - [Вложенные операторы условия. Пример](#вложенные-операторы-условия-пример)
    - [12. Операторы цикла. Цикл с условием. Операторы break и continue. Примеры использования](#12-операторы-цикла-цикл-с-условием-операторы-break-и-continue-примеры-использования)
      - [Цикл. Определение](#цикл-определение)
      - [Операторы цикла](#операторы-цикла)
      - [Цикл с условием](#цикл-с-условием)
      - [Операторы break и continue](#операторы-break-и-continue)
    - [13. Операторы цикла. Цикл с итератором. Функция range(). Примеры использования](#13-операторы-цикла-цикл-с-итератором-функция-range-примеры-использования)
      - [Цикл. Определение](#цикл-определение-1)
      - [Операторы цикла](#операторы-цикла-1)
      - [Цикл с итератором](#цикл-с-итератором)
      - [Функция range()](#функция-range)
    - [14. Изменяемые и неизменяемые типы данных](#14-изменяемые-и-неизменяемые-типы-данных)
    - [15. Списки. Основные функции, методы, операторы для работы со списками](#15-списки-основные-функции-методы-операторы-для-работы-со-списками)
      - [Список](#список)
      - [Основные функции](#основные-функции)
      - [Основные методы](#основные-методы)
      - [Операторы](#операторы)
    - [16. Списки. Создание списков. Списковые включения](#16-списки-создание-списков-списковые-включения)
      - [Списки](#списки)
      - [Списковые включения](#списковые-включения)
      - [Создание списков](#создание-списков)
    - [17. Списки. Основные методы для работы с элементами списка. Добавление элемента, вставка, удаление, поиск](#17-списки-основные-методы-для-работы-с-элементами-списка-добавление-элемента-вставка-удаление-поиск)
      - [Списки](#списки-1)
      - [Основные методы для работы с элементами списка](#основные-методы-для-работы-с-элементами-списка)
      - [Добавление, вставка, удаление и поиск элемента](#добавление-вставка-удаление-и-поиск-элемента)
    - [18. Списки. Основные операции со списками. Поиск минимального элемента. Поиск максимального элемента. Нахождение количества элементов. Нахождение суммы и произведения элементов](#18-списки-основные-операции-со-списками-поиск-минимального-элемента-поиск-максимального-элемента-нахождение-количества-элементов-нахождение-суммы-и-произведения-элементов)
      - [Списки](#списки-2)
      - [Основные операции со списками](#основные-операции-со-списками)
      - [Поиск минимального или максимального элемента](#поиск-минимального-или-максимального-элемента)
      - [Нахождение количества элементов](#нахождение-количества-элементов)
      - [Сумма и произведение элементов](#сумма-и-произведение-элементов)
    - [19. Списки. Использование срезов при обработке списков](#19-списки-использование-срезов-при-обработке-списков)
      - [Списки](#списки-3)
    - [Использование срезов](#использование-срезов)
    - [20. Кортежи. Основные функции, методы, операторы для работы с кортежами](#20-кортежи-основные-функции-методы-операторы-для-работы-с-кортежами)
      - [Кортежи](#кортежи)
      - [Функции, методы, операторы](#функции-методы-операторы)
    - [21. Словари. Понятие ключей и значений. Создание словарей. Основные функции, методы, операторы для работы со словарями](#21-словари-понятие-ключей-и-значений-создание-словарей-основные-функции-методы-операторы-для-работы-со-словарями)
      - [Словари](#словари)
      - [Создание словарей](#создание-словарей)
      - [Основные операторы, функции и методы](#основные-операторы-функции-и-методы)
    - [22. Множества. Основные функции, методы, операторы для работы с множествами](#22-множества-основные-функции-методы-операторы-для-работы-с-множествами)
      - [Множества](#множества)
      - [Основные функции, методы и операторы](#основные-функции-методы-и-операторы)
    - [23. Строки. Основные функции, методы, операторы для работы со строками. Срезы](#23-строки-основные-функции-методы-операторы-для-работы-со-строками-срезы)
      - [Строка](#строка)
      - [Основные функции, методы, операторы](#основные-функции-методы-операторы)
      - [Срезы](#срезы)
    - [24. Матрицы. Создание матрицы. Ввод и вывод матрицы. Выполнение операций с элементами матрицы](#24-матрицы-создание-матрицы-ввод-и-вывод-матрицы-выполнение-операций-с-элементами-матрицы)
      - [Матрицы](#матрицы)
      - [Создание](#создание)
      - [Операции с матрицами](#операции-с-матрицами)
    - [25. Матрицы. Квадратные матрицы. Обработка верхне- и нижнетреугольных матриц. Работа с диагональными элементами матрицы](#25-матрицы-квадратные-матрицы-обработка-верхне--и-нижнетреугольных-матриц-работа-с-диагональными-элементами-матрицы)
      - [Матрицы](#матрицы-1)
      - [Обработка диагоналей](#обработка-диагоналей)
      - [Обработка треугольных матриц](#обработка-треугольных-матриц)
    - [26. Отладка программы. Способы отладки](#26-отладка-программы-способы-отладки)
    - [27. Подпрограммы. Функции. Создание функции. Аргументы функции. Возвращаемое значение](#27-подпрограммы-функции-создание-функции-аргументы-функции-возвращаемое-значение)
      - [Подпрограмма](#подпрограмма)
      - [Функции](#функции)
      - [Аргументы функции](#аргументы-функции)
    - [28. Функции. Области видимости](#28-функции-области-видимости)
      - [Функции](#функции-1)
      - [Области видимости](#области-видимости)
    - [29. Функции. Завершение работы функции. Рекурсивные функции. Прямая и косвенная рекурсия](#29-функции-завершение-работы-функции-рекурсивные-функции-прямая-и-косвенная-рекурсия)
      - [Функции](#функции-2)
      - [Завершение работы функции](#завершение-работы-функции)
      - [Прямые, косвенные рекурсивные функции](#прямые-косвенные-рекурсивные-функции)
    - [30. Функции высшего порядка. Замыкания](#30-функции-высшего-порядка-замыкания)
      - [Функции высшего порядка](#функции-высшего-порядка)
      - [Замыкания](#замыкания)
    - [31. lambda-функции](#31-lambda-функции)
    - [32. Аннотации](#32-аннотации)
    - [33. Функции map, filter, reduce, zip](#33-функции-map-filter-reduce-zip)
      - [Функция `map`](#функция-map)
      - [Функция `filter`](#функция-filter)
      - [Функция `reduce`](#функция-reduce)
      - [Функция `zip`](#функция-zip)
    - [34. Декораторы](#34-декораторы)
    - [35. Знак `_`. Варианты использования](#35-знак-_-варианты-использования)
    - [36. Модули. Способы подключения](#36-модули-способы-подключения)
      - [Модули](#модули)
      - [Способы подлючения](#способы-подлючения)
    - [37. Модуль math. Основные функции модуля. Примеры использования функций](#37-модуль-math-основные-функции-модуля-примеры-использования-функций)
    - [38. Модуль time](#38-модуль-time)
    - [39. Модуль random. Работа со случайными числами](#39-модуль-random-работа-со-случайными-числами)
    - [40. Модуль copy. Способы копирования объектов различных типов. "Глубокая" и "мелкая" копии](#40-модуль-copy-способы-копирования-объектов-различных-типов-глубокая-и-мелкая-копии)
      - [Модуль copy и способы копирования объектов](#модуль-copy-и-способы-копирования-объектов)
      - [Глубокая и мелкая копия](#глубокая-и-мелкая-копия)
    - [41. Объектно-ориентированное программирование. Основные понятия ООП](#41-объектно-ориентированное-программирование-основные-понятия-ооп)
      - [ООП](#ооп)
      - [Основные понятия ООП](#основные-понятия-ооп)
    - [42. Исключения](#42-исключения)
    - [43. Файлы. Программная обработка файлов. Понятие дескриптора. Виды файлов](#43-файлы-программная-обработка-файлов-понятие-дескриптора-виды-файлов)
      - [Файл](#файл)
      - [Программная обработка файла](#программная-обработка-файла)
      - [Понятие дескриптора](#понятие-дескриптора)
      - [Виды файлов](#виды-файлов)
    - [44. Файлы. Режимы доступа к файлам](#44-файлы-режимы-доступа-к-файлам)
      - [Файл](#файл-1)
      - [Режимы доступа к файлам](#режимы-доступа-к-файлам)
    - [45. Файлы. Текстовые файлы. Основные методы для работы](#45-файлы-текстовые-файлы-основные-методы-для-работы)
      - [Файл](#файл-2)
      - [Текстовые файлы](#текстовые-файлы)
      - [Открытие текстового файла](#открытие-текстового-файла)
      - [Методы работы с текстовыми файлами](#методы-работы-с-текстовыми-файлами)
    - [46. Файлы. Текстовые файлы. Чтение файла. Запись в файл. Поиск в файле](#46-файлы-текстовые-файлы-чтение-файла-запись-в-файл-поиск-в-файле)
      - [Файл](#файл-3)
      - [Текстовые файлы](#текстовые-файлы-1)
      - [Чтение текстового файла](#чтение-текстового-файла)
      - [Запись в текстовый файл](#запись-в-текстовый-файл)
      - [Поиск в файле](#поиск-в-файле)
    - [47. Файлы. Текстовые файлы. Итерационное чтение содержимого файла](#47-файлы-текстовые-файлы-итерационное-чтение-содержимого-файла)
      - [Файл](#файл-4)
      - [Текстовые файлы](#текстовые-файлы-2)
      - [Итерационное чтение файла](#итерационное-чтение-файла)
    - [48. Файлы. Бинарные файлы. Основные методы. Сериализация данных](#48-файлы-бинарные-файлы-основные-методы-сериализация-данных)
      - [Файл](#файл-5)
      - [Бинарный файл](#бинарный-файл)
      - [Открытие бинарного файла](#открытие-бинарного-файла)
      - [Методы бинарных файлов](#методы-бинарных-файлов)
    - [49. Файлы. Оператор with. Исключения при работе с файлами](#49-файлы-оператор-with-исключения-при-работе-с-файлами)
      - [Файл](#файл-6)
      - [Оператор with](#оператор-with)
      - [Исключение при работе с файлами](#исключение-при-работе-с-файлами)
    - [50. Типы данных bytes и bytearray. Байтовые строки. Конвертация различных типов в байтовые строки и обратно](#50-типы-данных-bytes-и-bytearray-байтовые-строки-конвертация-различных-типов-в-байтовые-строки-и-обратно)
      - [Типы данных bytes и bytearray, байтовые строки](#типы-данных-bytes-и-bytearray-байтовые-строки)
      - [Конвертация в байты и обратно](#конвертация-в-байты-и-обратно)
    - [51. Модуль struct](#51-модуль-struct)
    - [52. Модуль os. Основные функции\`](#52-модуль-os-основные-функции)
      - [Модуль os](#модуль-os)
      - [Основные функции](#основные-функции-1)
    - [53. \*Генераторы](#53-генераторы)
    - [54. Модуль numpy. Обработка массивов с использованием данного модуля. Работа с числами и вычислениями](#54-модуль-numpy-обработка-массивов-с-использованием-данного-модуля-работа-с-числами-и-вычислениями)
    - [55. Модуль matplotlib. Построение графиков в декартовой системе координат. Управление областью рисования](#55-модуль-matplotlib-построение-графиков-в-декартовой-системе-координат-управление-областью-рисования)
    - [56. Модуль matplotlib. Построение гистограмм и круговых диаграмм](#56-модуль-matplotlib-построение-гистограмм-и-круговых-диаграмм)
    - [57. Списки. Сортировка. Сортировка вставками. Сортировка выбором](#57-списки-сортировка-сортировка-вставками-сортировка-выбором)
      - [Списки](#списки-4)
      - [Сортировка вставками](#сортировка-вставками)
      - [Сортировка выбором](#сортировка-выбором)
    - [58. Списки. Сортировка вставками. Метод простых вставок. Метод вставок с бинарным поиском. Вставки с барьером. Метод Шелла](#58-списки-сортировка-вставками-метод-простых-вставок-метод-вставок-с-бинарным-поиском-вставки-с-барьером-метод-шелла)
      - [Списки](#списки-5)
      - [Метод простых вставок](#метод-простых-вставок)
      - [Метод вставок с бинарным поиском](#метод-вставок-с-бинарным-поиском)
    - [59. Списки. Сортировка. Обменные методы сортировки. Сортировка пузырьком. Сортировка пузырьком с флагом. Метод шейкер-сортировки](#59-списки-сортировка-обменные-методы-сортировки-сортировка-пузырьком-сортировка-пузырьком-с-флагом-метод-шейкер-сортировки)
      - [Списки](#списки-6)
      - [Сортировка пузырьком](#сортировка-пузырьком)
      - [Сортировка пузырьком с флагом](#сортировка-пузырьком-с-флагом)
      - [Метод шейкер-сортировки](#метод-шейкер-сортировки)
    - [60. Списки. Сортировка. Метод быстрой сортировки](#60-списки-сортировка-метод-быстрой-сортировки)
      - [Списки](#списки-7)
      - [Быстрая сортировка](#быстрая-сортировка)

<div style="page-break-after: always;"></div>

### 1. Электронная вычислительная машина. Устройство ЭВМ. Программа. Исходный текст, исполняемый файл

#### ЭВМ

_ЭВМ_ — основной вид реализации компьютеров, который технически выполнен на электронных элементах. 

_Компьютер_ — устройство, способное выполнять заданную, чётко
определённую, изменяемую последовательность операций (численные расчёты, преобразование данных и т. д.).

#### Устройство ЭВМ

![Схема ЭВМ](./images/computer.png)

> Примечание автора: сколько людей, столько и схем ЭВМ. На лекциях нам давали что-то похожее.

#### Программа и исходный текст

_Исполняемая программа_ — сочетание компьютерных инструкций и данных, позволяющее аппаратному обеспечению вычислительной системы выполнять вычисления или функции управления.

_Исходный текст программы_ — синтаксическая единица, которая соответствует правилам определённого языка программирования и состоит из инструкций и описания данных, необходимых для решения определённой задачи.

---

### 2. Схемы алгоритмов

#### Нестрогое определение

> От автора: [PDF полной версии ГОСТа тут](http://www.robot.bmstu.ru/files/GOST/gost_19.701-90.pdf)

_Схема алгоритмов_ (она же _блок-схема_) — схема, описывающая алгоритм или процесс в виде блоков различной формы, соединённых между собой линиями и стрелками.

#### Основные блоки

![Основные блоки схем алгоритмов](images/flowchart.png)

---

### 3. Языки программирования. Классификация

#### Язык программирования. Определение

_Язык программирования_ — формальный язык, предназначенный для записи компьютерных программ. Язык программирования определяет набор лексических, синтаксических и семантических правил, определяющих действия, которые выполнит ЭВМ под её управлением.

#### Классификация

- По уровню абстракции от аппаратной части:
    - низкоуровневые
    - высокоуровневые
- По способу выполнения исполняемой программы:
    - компилируемые
    - интерпретируемые
- По парадигме программирования:
    - императивные / процедурные языки
    - аппликативные / функциональные языки
    - языки системы правил / декларативные языки
    - объектно-ориентированные языки

---

### 4. Язык Python. Структура программы. Лексемы языка

#### Язык программирования Python

Python - высокоуровневый язык программирования общего назначения. Интерпретируемый. Является полностью объектно-ориентированным.

> Примечание автора: здесь и далее речь идёт о _третьей_ версии — `Python 3` ([читается как _пайтон_](https://csn.khai.edu/ru/news/interesnyj-fakt-nazvanie-yazyka-programmirovaniya-python)). `Python 2` заметно отличается от последнего.

#### Структура программы

Программа -> Модули -> Операторы -> Выражения -> Объекты

#### Лексемы языка Python

Символы алфавита любого языка программирования образуют _лексемы_.

_Лексема (token)_ – это минимальная единица языка, имеющая самостоятельный смысл. Лексемы формируют базовый словарь языка, понятный компилятору.

Всего существует пять видов лексем:
- ключевые слова (keywords)
    - Пример: `if`, `for`, `def` и т.п.
- идентификаторы (identifiers)
    - Пример: названия переменных, функций и т.п.
- литералы (literals)
    - Пример: `"hello world!"`, `42` и т.п.
- операции (operators)
    - Пример: `+`, `=`, `and`, `in` и т.п.
- знаки пунктуации (разделители, punctuators)
    - `,`, `;` и т.п.

---

### 5. Типы данных языка Python. Классификация. Скалярные типы данных. Приведение типов

#### Типы данных

_Данные_ — поддающееся многократной интерпретации представление информации в формализованном виде, пригодном для передачи, связи, или обработки.

_Тип данных_ — множество значений и операций над этими значениями.

#### Классификация

Основные способы классификации типов данных:
- скалярные и нескалярные;
- самостоятельные и зависимые (в том числе ссылочные).

#### Типы данных

Скалярные:
- Число — `int`, `float`
- Логический тип — `bool`

Нескалярные:
- Строка — `str`
- Список — `list`
- Словарь — `dict`
- Кортеж — `tuple`
- Множество — `set`
- Файл
- Прочие основные типы
- Типы программных единиц
- Типы, связанные с реализацией

#### Приведение типов

_Приведение типа_ — преобразование значение одного типа в другое.

Бывает _явное_ и _неявное_.

_Неявное_:
- 123 + 3.14

> Комментарий: здесь первое значение сначало _неявно_ приводится к типу `float`, и лишь потом происходит сложение.

_Явное_:
- `int(3.14)`
- `str(obj)`

---

### 6. Операции над скалярными типами данных. Приоритеты операций

#### Над числами

- `x + y` — сложение
  - `40 + 2 = 42`
- `x - y` — вычитание
  - `16 - 2 = 14`  
- `x * y` — умножение
  - `16 * 2 = 32` 
- `x / y` — деление
  - `3 / 2 = 1.5`   
- `x // y` — целочисленное деление
  - `5 // 2 = 2` 
- `x % y` — остаток от деления
  - `5 % 2 = 1`
- `x ** y` — возведение в степень
  - `2 ** 5 = 32`
- `-x` — унарный минус
  - `x = 2; -x = -2`
- `+x` — если бы мы знали, что это такое, но мы не знаем, что это такое
- `x | y` — побитовое ИЛИ
  - `0b0101 | 0b0011 = 0b0111`
- `x & y` — побитовое И
  - `0b0101 & 0b0011 = 0b0001`
- `x ^ y` — побитовый ИСКЛЮЧАЮЩЕЕ ИЛИ
  - `0b0101 ^ 0b0011 = 0b0010`
- `~x` — побитовое отрицание
  - `~0b0101 = 0b1010`
- `x << y` — побитовый сдвиг влево
  - `0b11010110 << 2 = 0b01011000`
- `x >> y` — побитовый сдвиг вправо
  - `0b11010110 >> 2 = 0b00110101`

#### Над логическими значениями

> Примечение автора: смотрим [документацию](https://docs.python.org/3/library/functions.html?highlight=bool#bool) и видим: <br>
> _The `bool` class is a subclass of `int`_ <br>
> А значит для него определены _почти_ (есть нюансы) все операции, что и для чисел. `True` эквивалетно `1`, а `False` — `0`.

- `and` — логическое И
- `or` — логическое ИЛИ
- `not` — логическое отрицание

#### Приоритеты операций

- `**`
- `~x`
- `+x`, `-x`
- `*`, `/`, `//`, `%`
- `+`, `-`
- `<<`, `>>`
- `&`
- `^`
- `|`
- `in`, `not in`, `is`, `is not`, `<`, `<=`, `>`, `>=`, `!=`, `==`
- `not x`
- `and`
- `or`

---

### 7. Функции ввода и вывода. Ввод данных

#### Ввод

```py
# String
name = input("Enter your name: ")

# Integer
num = int(input("Enter integer number: "))

# Float
some_float_value = float(input())

# List
list_of_strings = input().split()
```

`prompt` — текст-приглашение к вводу

#### Вывод

```py
print(*objects, sep=" ", end="\n", file=sys.stdout, flush=True)
```

- `*objects` — любое количество объектов, являющихся строками или поддерживающие приведение к ним (метод `__str__`).
- `sep` — он же сепаратор. Строка, которая будет при выводе вставлена между отдельно переданными строками (см. пример ниже). По умолчанию — пробел.
- `end` — строка, которая будет добавлена в конец вывода. По умолчанию — `\n`, т.е. перевод на новую строку.
- `file` — куда будет напечатан результат. Обычно — `sys.stdout`, `sys.stderr` или обыкновенный файл. По умолчанию — `sys.stdout`.

```py
# Examples
print("Hello, world!")

print("Hello", "world", sep=", ", end="!\n")    # Hello, world!

print("Error: something is wrong", file=sys.stderr)
```

-— 

### 8. Функции ввода и вывода. Функция вывода. Форматирование вывода

> Тоже самое, как и в вопросе 7

#### Форматирование вывода

```bnf
replacement_field ::= "{" [field_name] ["!" conversion] [":" format_spec] "}"
conversion ::= "r" | "s" | "a"
format_spec       ::= [[fill]align][sign][#][0][width][grouping_option]["."precision][type]
fill              ::= any
align             ::= "<" | ">" | "=" | "^"
sign              ::= "+" | "-" | " "
width             ::= digit+
grouping_option   ::= "_" | ","
precision         ::= digit+
type              ::= "b" | "c" | "d" | "e" | "E" | "f" | "F" | "g" | "G" | "n" | "o" | "s" | "x" | "X" | "%"
```

> От автора: "что ЭТО такое?!" — это всего лишь [простая форма Бэкуса — Наура (БНФ)](https://divancoder.ru/2017/06/backus-naur-form/). Не волнуйтесь, её читать несложно. Особенно после регулярных выражений. Чтобы было ещё понятнее, покажу на примере.

Пример для `float`:
```py
number = 42.0
print(f"{number:'='^12.5f}")  # out: '==42.00000=='
#        ^^^^^^  ^ ^ ^ ^^
# field_name _|  | | | ||
#          fill _| | | ||
#           align _| | ||
#             width _| ||
#            pecision _||
#                 type _|
```

- `field_name` — что форматируем
- `fill` — чем заполняем пустоты, которые образуются при выравнивании (`align`)
- `align` — выравнивание `<`, `>`, `=`, `^`
- `width` — ширина выравнивания
- `precision` — точность указываемого значения для `float`
- `type` — как форматировать

Пример для строк `str`:
```py
s = "Hello!"
print(f"{s!r:-<12}")    # 'Hello!'----
#         ^
#         |_ conversion
```

- `conversion` — как выводить строку (например, `r` экранирует все спец. символы и добавляет `'` на границах)

---

### 9. Оператор присваивания. Множественное присваивание

#### Оператор присваивания

_Оператор присваивания_ предназначен для связывания имен со
значениями и для изменения атрибутов или элементов изменяемых
объектов. Оператор присваивания связывает переменную с объектом. Обозначается `=`.

#### Множественное присваивание

Примеры:
```py
a, b = "foo", "bar"

a, b = b, a

pos = (0, 4)
x, y = pos
```

#### Комбинированное присваивание

- `+=`
- `-=`
- `*=`
- `/=`
- `//=`
- `%=`
- `**=`
- `&=`
- `|=`
- `>>=`
- `<<=`

Выполняет действие над значеним и присваивает результут тому же имени.

---

### 10. Условный оператор. Полные условные операторы. Неполные условные операторы. Тернарный оператор условия. Примеры использования

#### Полный условный оператор

```py
if expr1:
    do_1()
elif expr2:
    do_2()
else:
    do_else()
```

#### Неполный условный оператор. Пример

```py
max_value = 0
if x > max_value:
    max_value = x
```

#### Тернарный оператор

```py
result = value_1 if condition else value_2
```
Эквивалетно
```py
if condition:
    result = value_1
else:
    result = value2
```

Пример:
```py
max_value = x if x > y else y
```

---

### 11. Условные операторы. Множественный выбор. Вложенные операторы условия. Примеры использования

#### Множественный выбор. Пример

Пример с некоторой реализацией меню:
```py
cmd = input()
if not cmd:
    pass
elif cmd == "q":
    quit()
elif cmd == "m":
    menu()
elif cmd == "a":
    action()
else:
    print("Неизвестная команда")
```

#### Вложенные операторы условия. Пример

Пример с обработкой аргументов командной строки (почему бы и нет?)
```py
arg = sys.argv[1]
if arg.startswith("--"):
    if arg == "--help":
        help()
    elif arg == "--interactive":
        run_interactive()
    elif arg == "--debug":
        debug()
    else:
        print(f"Неизвестный параметр:", arg)
        usage()
        exit(2)
elif arg.startswith("-"):
    if arg == "-h":
        help()
    elif arg == "-i":
        run_interactive()
    elif arg == "-d":
        debug()
    else:
        print(f"Неизвестный параметр:", arg)
        usage()
        exit(2)
```

---

### 12. Операторы цикла. Цикл с условием. Операторы break и continue. Примеры использования

#### Цикл. Определение

_Цикл_ — разновидность управляющей конструкции в высокоуровневых языках программирования, предназначенная для организации многократного исполнения набора инструкций.

#### Операторы цикла

- `while`
- `for`

#### Цикл с условием

```py
while condition_is_true:
    do_something()
else:
    do_if_no_breaked()
```

#### Операторы break и continue

`continue` — переходит в начало ближайшего заключающего цикла (в строку заголовка цикла)

```py
while y < size:
    while x < size:   # <---+
        if x == 5:    #     | continue
            continue  # >---+
        print(x, y)
```

`break` — переходит за пределы ближайшего заключающего цикла (после всего оператора цикла)

```py
while y < size:  # <--------+
    while x < size:   #     |
        if x == 5:    #     | break
            break     # >---+
        print(x, y)
```

---

### 13. Операторы цикла. Цикл с итератором. Функция range(). Примеры использования

#### Цикл. Определение

_Цикл_ — разновидность управляющей конструкции в высокоуровневых языках программирования, предназначенная для организации многократного исполнения набора инструкций.

#### Операторы цикла

- `while`
- `for`

#### Цикл с итератором

```py
for iterator in iterable:
    do_something()
else:
    do_if_no_breaked()
```

#### Функция range()

```py
range(start = 0, stop, step = 1)
```

Порождает серию целых чисел `start <= n < stop` с шагом `step`.

> А вот тут в лекциях, очевидно, ошибка. Рабочий контр-пример ниже. Поэтому приведу своё определение <br>
> Функция `range(start, stop, step)` возвращает объект, создающий последовательность чисел, начинающуюся с `start`, изменяемая каждую итерацию на `step` и останавливающуюся, когда достигает значения `stop`. 

```py
for i in range(5, -1, -1):
  print(i)
# 5, 4, 3, 2, 1, 0
```

---

### 14. Изменяемые и неизменяемые типы данных

Неизменяемые:
- `int`
- `float`
- `str`
- `bytes`
- `tuple`

Изменяемые
- `list`
- `dict`
- `set`
- и др.

Неизменяемые типы данных, как ни странно, не изменяемы:
(`id` — возвращает уникальный идентификатор объекта)
```py
>>> a = 5
>>> id(a)
139709610098536
>>> a += 1
>>> id(a)
139709610098568
```
При попытке изменить неизменяемое значение, имени присваивается другой участок памяти (см. пример выше).

Изменяемые же ведут себя предсказуемо:
```py
>>> l = [1, 2]
>>> id(l)
139709375880640
>>> l.append(3)
>>> id(l)
139709375880640
```

Из этого следует поведение неизменяемых и изменяемых объектов при передачу в функцию:

```py
def inc(x: int):
  x += 1

a = 5
inc(a)
print(a)    # 5


def append_one(x: list):
  x.append(1)

l = [1, 2]
append_one(l)
print(l)    # [1, 2, 1]  
```

---

### 15. Списки. Основные функции, методы, операторы для работы со списками

#### Список

_Коллекция_ — объект, содержащий в себе набор значений одного или
различных типов и позволяющий обращаться к этим значениям.

_Списки_ — упорядоченные изменяемые коллекции объектов произвольных типов (почти как массив, но типы могут отличаться).

> От автора: в `Python`-е, как ни странно, _списки реализованы в виде динамических массивов указателей_, а не как односвязанные списки. Больше можно прочитать [тут](https://antonz.org/list-internals/).

#### Основные функции

- `all()` — возвращает True, если все элементы истинны или список пуст
- `enumerate(iterable, start=0)` — возвращает итератор последовательности кортежей (индекс, значение)
- `len(s)` — количество элементов списка
- `max(iterable)`
- `min(iterable)`
- `print()`
- `reversed(seq)` — возвращает итератор. Не создаёт копию последовательности. `b = list(reversed(a))`.
- `sorted(iterable, key = None, reverse = False)`
- `sum(iterable)`

#### Основные методы

- `append(x)` — добавление элемента x в конец списка
- `extend(iterable)` — расширение списка с помощью итерируемого объекта
- `insert(i, x)` — вставка x в i-ю позицию. Если i за границами списка, то вставка происходит в конец/начало списка
- `remove(x)` — удаляет первый элемент со значением x
- `pop([i])` — удаляет элемент в позиции i. Если аргумент не указан, удаляется
последний элемент списка
- `clear()` — удаляет все элементы из списка
- `index(x[, start[, end]])` — возвращает индекс (с 0) первого элемента, равного x
- `count(x)` — возвращает количество вхождений x в список
- `sort(key=None, reverse=False)` — сортировка списка
- `reverse()` — разворачивает список (переставляет элементы в обратном
порядке)
- `copy()` — создание "мелкой" копии

#### Операторы

- `+` — конкатенация списков. Аналогично `extend`, но только для списков
- `*` — "умножение" списка: `[ 0 ] * 5 => [ 0, 0, 0, 0, 0 ]`
- `in` — принадлежность значения списку
- `del` — удаление самого списка или его элемента
- `==` — сравнение списков на совпадение элементов с учётом порядка
- `>`, `>=`, `<`, `<=` — сравнение списков с учётом лексикографического порядка элементов

---

### 16. Списки. Создание списков. Списковые включения

#### Списки

См. ответ на вопрос №15

#### Списковые включения 

Он же _генератор списков_:

```py
l = [ value for iterator in iterable if condition ]

# Example
l = [ i**2 for i in range(5) ]  # [0, 1, 4, 9, 16]
```

#### Создание списков

- `l = []` или `l = list()` — пустой список
- `l = [0] * 5` — список с начальными значениями
- `l = [ i for i in range(5) ]` — при помощи генератора списков

---

### 17. Списки. Основные методы для работы с элементами списка. Добавление элемента, вставка, удаление, поиск

#### Списки

См. ответ на вопрос №15.

#### Основные методы для работы с элементами списка

См. ответ на вопрос #15.

#### Добавление, вставка, удаление и поиск элемента

Добавление:
```py
>>> l = list()
>>> l.append(5)
>>> l
[5]
```
Добавление в конец имеет сложность `O(1)`.

Вставка:
```py
>>> l = [0, 2]
>>> l.insert(1, 1)
>>> l
[0, 1, 2]
```
Вставка имеет максимальную сложность `O(n)`.

Доступ по индексу
```py
>>> l = [0, 2]
>>> l[1]
2
```
Доступ по индексы имеет сложность `O(1)` (помним, что списки в `Python`-е — это массивы).

Удаление элемента по значению:
```py
>>> l = [1, 2, 3]
>>> l.remove(2)
>>> l
[1, 3]
```

Удаление элемента по индексу:
```py
>>> l = [1, 2, 3]
>>> l.pop(1)
2
>>> l
[1, 3]
```

Удаление значения имеет максимальную сложность `O(n)`.

Поиск:
```py
>>> l = [1, 2, 3]
>>> found = None
>>> for i, it in enumerate(l):
...     if it == 2:
...         found = i
...         break
... 
>>> if found is not None:
...     found
2
```

Или:
```py
>>> l = [1, 2, 3]
>>> l.index(2)
1               # OR ValueError, if not found
```

Линейный поиск значения имеет максимальную сложность `O(n)`.

---

### 18. Списки. Основные операции со списками. Поиск минимального элемента. Поиск максимального элемента. Нахождение количества элементов. Нахождение суммы и произведения элементов

#### Списки

См. ответ на вопрос №15.

#### Основные операции со списками

См. ответ на вопрос #15.

#### Поиск минимального или максимального элемента

Поиск минимального:
```py
from math import inf
l = [ ... ]
min_ = inf
for i, it in enumerate(l):
    if it < min_:
        min_ = it
        index = i
print(f"Min: l[{index}] = {min_}")
```

Поиск максимального:
```py
from math import inf
l = [ ... ]
max_ = -inf
for i, it in enumerate(l):
    if it < max_:
        max_ = it
        index = i
print(f"Max: l[{index}] = {max_}")
```

Если нужно найти только само значение минимума/максимума (без индекса):
```py
>>> l = [-1, 0, 1]
>>> min(l)
-1
>>> max(l)
1
```

#### Нахождение количества элементов

```py
>>> l = [1, 2, 2]
>>> l.count(2)
2
```

#### Сумма и произведение элементов

Сумма:
```py
>>> l = [1, 2, 3]
>>> sum(l)
6
```

Произведение:
```py
l = [...]
prod = 1
for it in l:
    prod *= it
print(prod)
```

Или через модуль `functools` (не очень законно, зато красиво)
```py
>>> import functools
>>> l = [1, 2, 3]
>>> functools.reduce(lambda res, current: res * current, l)
6
```

---

### 19. Списки. Использование срезов при обработке списков

#### Списки

См. ответ на вопрос №15.

### Использование срезов

_Срез_ — объект, представляющий набор индексов, а также метод (способ), используемый для представления некоторой части последовательности
```py
l[start:stop:step]
```

Рассмотреть список после определённого значения (например, обработка параметров командной строки)
```py
import sys
program_path = sys.argv[0]
for argument in sys.argv[1:]:
    ...
```

> От автора: можно придумать ещё множество примеров... но пока пусть будет так.

---

### 20. Кортежи. Основные функции, методы, операторы для работы с кортежами

#### Кортежи

_Кортеж_ - неизменяемая последовательность (как список, только неизменяем).

Создание: 
```py
a = tuple() # Empty tuple
b = 1,      # Tuple with 1 element
c = (1, )
d = 1, 2    # (1, 2)
```

#### Функции, методы, операторы

Функции — все как у списков.
Методы — `index(x)` и `count(x)`
Операторы: — `in`, `not in`

---

### 21. Словари. Понятие ключей и значений. Создание словарей. Основные функции, методы, операторы для работы со словарями

#### Словари

_Словари_ — неупорядоченные коллекции произвольных объектов с доступом по
ключу.

> Примечание автора: это буквально _хэш-таблица_, если вы понимаете, о чём я

Каждому _ключу_ соответствует единственное _значение_. Ключи обязательно должны быть _хэшируемыми_ и _сравнимыми_.

```py
>>> { []: 5 }
Traceback (most recent call last):
  File "<stdin>", line 1, in <module>
TypeError: unhashable type: 'list'
```

#### Создание словарей

```py
a = dict()  # Empty dictionary
b = { 1: "a" }
c = dict.fromkeys([1, 2], None)     # { 1: None, 2: None }
d = { a: a**2 for a in range(3) }   # { 0: 0, 1: 1, 2: 4 }  
```

#### Основные операторы, функции и методы

Операторы:
- `del` — удалить пару ключ-значение
- `in` — проверить, есть ли ключ в словаре
- `not in`
- `|` — расширить словарь другим словарём
- `|=` — расширить словарь другим словарём и присвоить результат первому имени

Функции:
Те же, что и для списков, только применяются к ключам (см. ответ на вопрос №15).

Методы:
- `clear()` - очищает словарь (удаляет все элементы)
- `copy()` - создаёт "мелкую" копию
- `fromkeys(iterable[, value])` - создаёт словарь на основе ключей и значения по умолчанию. Это _метод класса_.
- `get(key[, default])` - возвращает значение по ключу либо `default` либо `None`.
- `items()` - возвращает отображение содержимого
- `keys()` - возвращает отображение ключей
- `pop(key[, default])` - удаляет значение из словаря и возвращает его, либо возвращает `default`, либо порождает исключение `KeyError`
- `popitem()` - возвращает последнюю добавленную в словарю пару либо порождает исключение `KeyError`
- `setdefault(key[, default])` - значение по умолчанию для метода get на случай отсутствия
ключа
- `update([other])` - обновляет значения по другому словарю, кортежу и т.п.
- `values()` - возвращает отображение значений

---

### 22. Множества. Основные функции, методы, операторы для работы с множествами

#### Множества

_Множество (set)_ — это неупорядоченная последовательность элементов, каждый из которых в множестве представлен ровно один раз.

Элементы множества должны быть _хэшируемыми_.

#### Основные функции, методы и операторы

Функции:
- `len(s)`

Методы:
- `isdisjoint(other)` — `True`, если нет пересечения
```py
>>> a = { 1, 2 }
>>> b = { 3, 4 }
>>> c = { 2, }
>>> a.isdisjoint(b)
True
>>> a.isdisjoint(c)
False
```
- `issubset(other)` — `True`, если является подмножеством, <=
```py
>>> a = { 1, 2 }
>>> b = { 3, 4 }
>>> c = { 2, }
>>> a.issubset(b)
False
>>> a.issubset(c)
False
>>> c.issubset(a)
True
```
- `issuperset(other)` — `True`, если является надмножеством, >=
```py
>>> a = { 1, 2 }
>>> b = { 3, 4 }
>>> c = { 2, }
>>> a.issubset(b)
False
>>> a.issubset(c)
True
>>> c.issubset(a)
False
```
- `union(*others)` — объедение множеств, не изменяет их
```py
>>> a = { 1, 2 }
>>> b = { 3, 4 }
>>> a.union(b)
{1, 2, 3, 4}
```
- `intersection(*others)` — пересечение множеств
```py
>>> a = { 1, 2 }
>>> d = { 2, 3, }
>>> a.intersection(d)
{2}
```
- `difference(*others)` — те элементы, что не вошли во второе множество
```py
>>> a = { 1, 2 }
>>> d = { 2, 3, }
>>> a.difference(d)
{1}
```
- `symmetric_difference(other)` — симметричная разность множеств
```py
>>> a = { 1, 2 }
>>> d = { 2, 3, }
>>> a.difference(d)
{1, 3}
```
- `copy()` — "мелкая" копия множества

- `update(*others)` — расширяет множество
- `intersection_update(*others)` — эквивалетно `s1 = s1.intersection(s2)`
- `difference_update(*others)` — эквивалетно `s1 = s1.difference(s2)`
- `symmetric_difference_update(other)` — эквивалетно `s1 = s1.symmetric_difference(s2)`
- `add(elem)` — добавляет элемент в множество
- `remove(elem)` — удаляет из множества, может порождать исключение `KeyError`
- `discard(elem)` — удаляет без исключения
- `pop()` — удаляет и возвращает элемент множества (какой — загадка вселенной...)
- `clear()` — очищает множество

---

### 23. Строки. Основные функции, методы, операторы для работы со строками. Срезы

#### Строка

_Строка (str)_ - тип данных, значениями которого является произвольная последовательность символов. Реализуется как массив символов. *Неизменяемы*.

```py
s = 'some "text"'
s = "some 'text'"
s = """a lot of 
text"""
s = ""      # Empty string
s = str()   # Empty string
s = str(object)
s = str(bytes, encoding="utf-8", errors="strict")
```

#### Основные функции, методы, операторы

Функции — все как у списков.

Методы:
- `capitalize()` — переводит первую букву в верхний регистр
- `casefold()` — один из способов перевода в нижний регистр
- `center(width[,fillchar])` — центрирует строку, дополняя пробелами с двух сторон
- `count(sub[,start[,end]])` — считает неперекрывающиеся вхождения подстроки в строку
- `encode(encoding="utf-8",erros="strict")` — кодирование в заданную кодировку
- `endswith(suffix[,start[,end]])` — проверка на окончание одним из суффиксов
- `expandtabs(tabsize=8)` — замена табуляций на пробелы
- `find(sub[,start[,end]])` — поиск подстроки в строке
- `format()`
- `index(sub[,start[,end]])` — аналогично ﬁnd, но порождает исключение ValueError, если вхождений нет
- `isalnum()` — если все символы буквенно-цифровые и строка не пустая
- `isalpha()` — если все символы - буквенные и строка не пустая
- `isascii()` — если все символы из таблицы ASCII
- `isdecimal()` — если символы цифровые в 10-й с/с и строка не пустая
- `isdigit()` — если символы цифровые в 10-й с/с и строка не пустая
- `isidentifier()` — является корректным идентификатором
- `islower()` — все символы в нижнем регистре и строка не пустая
- `isnumeric()` — все символы являются “числовыми” и строка не пустая
- `isprintable()` — все символы “печатные” или строка пустая
- `isspace()` — все символы “пробельные” и строка не пустая
- `istitle()` — все символы в верхнем регистре и строка не пустая
- `isupper()` — все символы в верхнем регистре и строка не пустая
- `join(iterable)` — конкатенирует строки
- `ljust(width[, fillchar])` — дополняет пробелами справа до заданной ширины
- `lower()` — переводит в нижний регистр
- `lstrip([chars])` — удаляет символы слева
- `partition(sep)` — разделяет строку на части по первому вхождению разделителя, возвращает кортеж из 3-х элементов
- `removeprefix(prefix)` — удаляет префикс
- `removesuffix(suffix)` — удаляет суффикс
- `replace(old, new[, count])` — заменяет все вхождения подстроки
- `rfind(sub[,start[,end]])` — ищет подстроку справа
- `rindex(sub[,start[,end]])` — ищет подстроку справа с исключением
- `rjust(width[,fillchar])` — дополняет пробелами слева до ширины
- `rpartition(sep)` — делит по разделителю, поиск справа
- `rsplit(sep = None, maxsplit=-1)` — возвращает список слов (частей), поиск справа
- `rstrip([chars])` — удаляет завершающие символы
- `split(sep=None, maxsplit=-1)` — возвращает список слов (частей) по разделителю
- `splitlines([keepends])` — делит на части по переводам строк
- `startswith(prefix[,start[,end]])` — если начинается с префикса
- `strip([chars])` — удаляет символы и из начала, и с конца
- `swapcase()` — меняет регистр
- `title()` — переводит первые буквы слов в верхний регистр
- `translate(table)` — преобразование символов по таблице
- `upper()` — переводит в верхний регистр
- `zfill()` — дополняет строку нулями слева

Операторы:
- `+`
- `*`
- `in`
- `not in`

#### Срезы

Аналогично как у списков

---

### 24. Матрицы. Создание матрицы. Ввод и вывод матрицы. Выполнение операций с элементами матрицы

#### Матрицы

_Матрица_ — двумерный массив.

#### Создание

Создание матрицы n x m:
```py
matrix = [ [0]*m for _ in range(n) ]
```

#### Операции с матрицами

Получение элемента n-ой строки и m-ого столбца:
```py
matrix[n][m]
```

Транспонирование матрицы
```py
m = ...
for y in range(len(m)):
    for x in range(y, len(m)):
        m[y][x], m[x][y] = m[x][y], m[y][x]
```

> От автора: можно ещё что-то придумать

---

### 25. Матрицы. Квадратные матрицы. Обработка верхне- и нижнетреугольных матриц. Работа с диагональными элементами матрицы

#### Матрицы

_Матрица_ — двумерный массив.

#### Обработка диагоналей

Главная диагональ
```py
for i in range(len(m)):
    print(f"{m[i][i]:>8}", end=" ")
```

Побочная диагональ (для неквадратной матрицы считаем, что это диагональ из левого ниженего угла)
```py
for i in range(len(m)):
    print(f"{m[len(m)-1 - i][i]:>8}", end=" ")
```

#### Обработка треугольных матриц

Верхнетреугольная матрица (над главной диагональю)
```py
for y in range(len(m)):
    for x in range(y+1, len(m)):
        print(f"{m[y][x]:>8}", end=" ")
    print()
```

Нижнетреугольная матрица (под главной диагональю)
```py
for y in range(len(m)):
    for x in range(y):
        print(f"{m[y][x]:>8}", end=" ")
    print()
```

---

### 26. Отладка программы. Способы отладки

_Отладка_ — этап разработки компьютерной программы, на котором
обнаруживают, локализуют и устраняют ошибки.

При отладке требуется:
- узнавать текущие значения переменных;
- выяснять, по какому пути выполнялась программа.

Способы отладки:
- использование отладочной печати (отладочного вывода);
- использование отладчика.

---

### 27. Подпрограммы. Функции. Создание функции. Аргументы функции. Возвращаемое значение

#### Подпрограмма

_Подпрограмма_ - поименованная или иным образом идентифицированная
отдельная функционально независимая часть компьютерной программы.

Подпрограммы делятся на _процедуры_ и _функции_.

#### Функции

Оператор `def` создаёт новый объект и присваивает его имени.
```py
def <name_of_function>(<arguments>):
    ...
```

Пример:
```py
def greet(name):
    print(f"Hello {name}!")

greet("Bob")    # out: Hello, Bob!
```

#### Аргументы функции

Присваивание _новых_ значений аргументам внутри функций не
затрагивает вызывающий код.

Модификация аргумента внутри функции:
- неизменяемого — создаст копию (не повлияет на вызывающий код),
- изменяемого — повлияет на вызывающий код (изменит значение в нём).
  
Виды параметров в Python:
- позиционные аргументы
- именованные аргументы
```py
#   positional args
#     v  v
def f(a, b, c=5, d=6):
#            ^    ^
#          named args
    ...
```

---

### 28. Функции. Области видимости

#### Функции

См. ответ на вопрос №27.

#### Области видимости

_Область видимости (scope)_ — это та часть кода, где переменная доступна, открыта и видима.

Области видимости:
1. _Глобальная_ — если переменная объявлена за пределами всех `def`, то она является "глобальной".
2. _Локальная_ — переменная, объявленная внутри `def`, будет локальной в своей фунции.
3. _Нелокальная_ — переменная, объявленная внутри `def`, включающем другие
`def` (см. Замыкания).
4. _Встроенная_ (built-in).

Оператор `global` делает имя внутри функции _глобальным_.
Оператор `nonlocal` делает имя внутри функции _нелокальным_.

(_Правило LEGB_) Поиск имени выполняется последовательно в:
1. local
2. enclosing (см. _Нелокальная_)
2. global
3. built-in

---

### 29. Функции. Завершение работы функции. Рекурсивные функции. Прямая и косвенная рекурсия

#### Функции

См. ответ на вопрос #27.

#### Завершение работы функции

При помощи оператора `return`:
```py
def greet(name):
    if not name:
        return
    print(f"Hello {name}!")
    return  # Optional
```

Исключения тоже завершают работу функции:
```py
def greet(name):
    if not name:
        raise ValueError("empty name is not allowed")
    print(f"Hello {name}!")
```

#### Прямые, косвенные рекурсивные функции

_Рекурсия_ — вызов подпрограммы из неё же самой:
- непосредственно — _прямая_ рекурсия;
- через другие подпрограммы — _косвенная_ рекурсия.

Тело рекурсивной подпрограммы должно иметь не меньше двух альтернативных (условных) ветвей, хотя бы одна из которых должна быть _терминальной_.

По количеству вызовов:
- _линейная_ — в теле функции присутствует только один вызов самой себя;
- _нелинейная_ — в теле присутствует несколько вызовов.

По месту расположения рекурсивного вызова:
- _головная_ — рекурсивный вызов расположен ближе к началу тела функции;
- _хвостовая_ — рекурсивный вызов является последним оператором функции.

---

### 30. Функции высшего порядка. Замыкания

#### Функции высшего порядка

_Функция первого порядка_ — та функция, которая принимает только
значения "простых" (не функциональных) типов и возвращает значения
таких же типов в качестве результата.

```py
def sum(iterable):
    res = 0
    for it in iterable:
        res += it
    return res
```

_Функция высшего порядка_ - та функция, которая принимает в качестве
аргументов или возвращает другие функции.

```py
def map(iterable, function):
    res = list()
    for it in iterable:
        res.append(function(it))
    return res
```

#### Замыкания

_Замыкание (closure)_ — функция первого порядка, в теле которой присутствуют ссылки на переменные, объявленные вне тела этой функции в окружающем коде и не являющиеся её параметрами.

```py
def outer():
    x = 1
    def inner():
        print('x in outer function: ', x)
    return inner
```

> От автора: слишком "стерильный" пример. Приведу реальные участки кода:

```py
def create_console_output_channel() -> OutputChannel:
    """ Возвращает функцию, печатающую в окно консоли """ 
    size = get_console_size()
    def console_output_channel(text: str) -> None:
        """ Печатает текст в консоль с учётом ширины окна """
        text = format_alignment(text, size.width)
        print(text, end="")
    return console_output_channel

...

out = create_console_output_channel()
out(very_long_text)
```
Функция `console_output_channel` является _замыканием_, а переменная `size` — нелокальной.

---

### 31. lambda-функции

Оператор `lambda` создаёт и возвращает объект функции, который будет вызываться позднее, не присваивая ему имени.

```py
lambda arg1, arg2...: expression
```

Например, лямбда-функция:
```py
lambda x, y: x + y
```

Эквивалентна:
```py
def sum_(x, y):
    return x + y
```

---

### 32. Аннотации

_Аннотации_ — способ добавлять произвольные метаданные к
аргументам функции и возвращаемому значению.

Пример из лекций:
```py
def div(a: 'the dividend',
        b: 'the divisor') -> 'the result of dividing a by b':
    """Divide a by b"""
    return a / b
```

> От автора: аннотации на самом деле очень мощный механизм, который позволяет добавить типизацию в код Ваших программ на `Python`-е. Подробнее [на youtube-канале Диджитализируй!](https://www.youtube.com/watch?v=dKxiHlZvULQ&t=638s&ab_channel=%D0%94%D0%B8%D0%B4%D0%B6%D0%B8%D1%82%D0%B0%D0%BB%D0%B8%D0%B7%D0%B8%D1%80%D1%83%D0%B9%21)

```py
def sum(a: int, b: int) -> int:
    return a + b
```

---

### 33. Функции map, filter, reduce, zip

#### Функция `map`

```py
map(function, iterable, ...)
```

Возвращает итератор, применяющий функцию к каждому элементу
итерируемого объекта.

```py
>>> l = [1, 2, 3]
>>> list(map(lambda x: x*x, l))
[1, 4, 9]
```

#### Функция `filter`

```py
filter(function, iterable, ...)
```

Возвращает итератор, с теми объектами последовательности, для которых
функция вернула True.

```py
>>> l = [1, 2, 3]
>>> list(filter(lambda x: x > 1, l))
[2, 3]
```

#### Функция `reduce`

```py
functools.reduce(function, iterable[, initializer])
```

Применяет функцию к элементам итерируемого объекта кумулятивно (накопительно): сначала — к первым двум элементам (либо к отдельно заданному начальному значению и первому элементу), далее - к промежуточному результату и очередному значению

Произведение всех элементов списка:
```py
>>> from functools import reduct
>>> l = [1, 2, 3]
>>> reduce(lambda res, current: res * current)
6
```

#### Функция `zip`

```py
zip(*iterables, strict=False)
```

Соединяет элементы итерируемых объектов в кортежи. Параметр `strict` (>=3.10) приводит к исключению, если длина
объектов отличается.

```py
>>> first_names = [ "Bob", "John" ]
>>> last_names = [ "Smith", "Brown" ]
>>> list(zip(first_names, last_names))
[("Bob", "Smith"), ("John", "Brown")]
```

---

### 34. Декораторы

_Декоратор_ — это функция, которая позволяет "обернуть" другую функцию для расширения её функциональности без непосредственного изменения её кода.

```py
@decorator
def function():
    ...
```

> Примечание автора: проще говоря, декоратор — это синтаксический сахар (т.е. упрощённая запись) вот этого:

```py
decorated_function = decorator(function)
```

На примере декоратора, который вычисляет время работы функции:
```py
def benchmark(function):
    from time import time
    def inner(*args, **kwargs):
        start = time()
        result = function(*args, **kwargs)
        end = time()
        measurement_s = end-start
        # Formatted out
        print(
            f"{function.__name__}"\
            f"({', '.join(map(str, list(args) + list(kwargs.keys())))})"\
            f" -> {measurement_s * 10**9}ns"
        )
        return result
    return inner

@benchmark
def some_function(a, b):
    ...
```

---

### 35. Знак `_`. Варианты использования

1. Хранение значения последнего выражения в интерпретаторе
```py
>>> 5 + 3
8
>>> a = _
>>> a
8
```

2. Игнорирование некоторых значений (при разыменовании кортежей и
т. д.)
```py
a, _ = (5, 6)
```
```py
for _ in range(5):
    ...
```

3. Задание специальных значений для имен переменных или функций
(\_\_init\_\_, \_\_name\_\_).

4. Приватные/защищённые поля/методы классов

---

### 36. Модули. Способы подключения

#### Модули

_Модуль_ — это файл, содержащий определения функций, классов и переменных, а также исполняемый код.

#### Способы подлючения

```py
import module
import module as m
import module1, module2
from module import a, b
from module import *
```

---

### 37. Модуль math. Основные функции модуля. Примеры использования функций

- `ceil(x)` — округление вверх
- `comb(n, k)` — биномиальный коеффициент
- `copysign(x, y)` — переносит знак со второго числа на первое
- `fabs(x)` — `abs` для `float`
- `factorial(x)` — факториал числа
- `floor(x)` — округление вниз
- `fmod(x, y)` — `%` для `float`
- `frexp(x)` — возвращает мантиссу и экспоненту числа
- `gcd(a,b)` — НОД
- `isclose(a, b, *, rel_tol=1e-09, abs_tol=0.0)`
- `isfinite(x)` — `True`, если число конечно
- `isinf(x)` — `True`, если число — бесконечность
- `isnan(x)` — `True`, если `NaN`
- `isqrt(n)` — возвращает целую часть квадратного корня от числа
- `lcm(a,b)` — НОК
- `ldexp(x, i)`
- `modf(x)`
- `perm(n, k=None)` — количество комбинаций/перестановок
- `trunc(x)` — округляет ближе к нулю
- `exp(x)` — e^x
- `expm1(x)` — e^x - 1
- `log(x[, base])` — логарифм по основанию
- `log1p(x)` — натуральный логарифм 1+x
- `log2(x)` — логарифм по основанию 2
- `log10(x)` — lg x
- `pow(x, y)` — x^y
- `sqrt(x)` — квадратный корень из x
- `acos(x)` — arccos(x)
- `asin(x)` — arcsin(x)
- `atan(x)` — arctan(x)
- `atan2(y, x)` — arctan(y/x)
- `cos(x)`
- `sin(x)`
- `tan(x)`
- `degrees(x)` — перевод из радиан в градусы
- `radians(x)` — перевод из градусов в радианы

---

### 38. Модуль time

Предоставляет функции для работы со временем
- `sleep(secs)` — задержка, в секундах.
- `time()` — время эпохи Юникc, Unix-время, время с 01.01.1970 00:00+00 в секундах.

---

### 39. Модуль random. Работа со случайными числами

Реализует генерацию псевдослучайных чисел различных распределений.

Функции состояния:
- `seed(a=None, version=2)`
- `getstate()`
- `setstate(state)`

Функция генерации последовательности байтов:
- `randbytes(n)`

Числовые функции:
- `randrange(stop), randrange(start, stop[, step])`
- `randint(a, b) (алиас для randrange(a, b+1))`
- `getrandbits(k)`

Функции последовательностей:
- `choice(seq)`
- `choices(population, weights=None, *, cum_weights=None, k=1)`
- `shuffle(x[, random])`
- `sample(population, k, counts=None)`

Распределения
- `random()`
- `uniform(a, b)`
- `triangular(low, high, mode)`
- `betavariate(alpha, beta)`
- `expovariate(lambd)`
- `gammavariate(alpha, beta)`
- `gauss(mu, sigma)`
- `lognormvariate(mu, sigma)`
- `normalvariate(mu, sigma)`
- `vonmisesvariate(mu, kappa)`
- `paretovariate(alpha)`
- `weibullvariate(alpha, beta)`

---

### 40. Модуль copy. Способы копирования объектов различных типов. "Глубокая" и "мелкая" копии

#### Модуль copy и способы копирования объектов

`copy(x)` — создаёт "мелкую" копию объекта
`deepcopy(x, [memo])` — создаёт глубокую копию

#### Глубокая и мелкая копия

`copy` не копирует объекты, входящие в состав копируемой переменной:
```py
>>> a = [1, []]
>>> id(a)
139838199418048
>>> id(a[0])
139838436048616
>>> id(a[1])
139838199075200
>>>
>>> b = copy(a)
>>> id(b)
139838200975552
>>> id(b[0])
139838436048616
>>> id(b[1])
139838199075200
```

`deepcopy` копирует все объекты, входящие в состав копируемой переменной:
```py
>>> a = [1, []]
>>> id(a)
139838199418048
>>> id(a[0])
139838436048616
>>> id(a[1])
139838199075200
>>>
>>> c = deepcopy(a)
>>> id(c)
139838200973184
>>> id(c[0])
139838436048616
>>> id(c[1])
139838199106048
```

---

### 41. Объектно-ориентированное программирование. Основные понятия ООП

#### ООП

_Объектно-ориентированное программирование (ООП)_ — методология, основанная на представлении программы в виде совокупности объектов, каждый из которых является экземпляром определённого класса.

#### Основные понятия ООП

_Класс_ — некоторый шаблон для создания объектов, обеспечивающий начальные значения состояния: инициализация полей-переменных и реализация поведения методов.

_Объект_ — это экземпляр с собственным состоянием этих свойств.

_Поле_ — некоторое "свойство", или атрибут, какого-то объекта (переменная, являющаяся его частью). Объявляется в классе.

_Метод_ — функция объекта, которая имеет доступ к его состоянию (полям). Реализуется в классе.

---

### 42. Исключения

_Исключения_ — тип данных, позволяющий классифицировать ошибки времени
выполнения и обрабатывать их.

```py
>>> 1/0
Traceback (most recent call last):
  File "<stdin>", line 1, in <module>
ZeroDivisionError: division by zero
```

Обработка исключения:
```py
while True:
    try:
        num = int(input("Enter integer number: "))
        break
    except ValueError:
        print("Please, enter correct integer number")
```

Создание исключения:
```py
def greet(name):
    if not isinstance(name, str):
        raise ValueError("argument name must be string")
    print(f"Hello, {name}!")
```

---

### 43. Файлы. Программная обработка файлов. Понятие дескриптора. Виды файлов

#### Файл
_Файл_ — поименованное место на носителе данных (внешняя память).

#### Программная обработка файла

В языках программирования обычно применяется концепция, в которой файл является абстракцией, не привязанной к конкретному типу носителя и файловой системе, а работа с файлами осуществляется подобно обработке массива данных.

#### Понятие дескриптора

Файловый дескриптор — целое число, которое присваивается операционной системой каждому потоку ввода-вывода при его создании.

#### Виды файлов

- текстовые файлы,
- структурированные (типизированные) форматы,
- бинарные файлы.

Формат файла определяется его содержимым. Расширение файла обычно соответствует формату файла, но в общем случае никак на него не влияет.

---

### 44. Файлы. Режимы доступа к файлам

#### Файл

_Файл_ — поименованное место на носителе данных (внешняя память).

#### Режимы доступа к файлам

- `r` — открытие для чтения (по умолчанию)
- `w` — открытие для записи, перезаписывает файл или создаёт новый
- `x` — создание файла для записи
- `a` — открытие для записи, добавляет в конец или создаёт новый
- `b` — в бинарном виде
- `t` — в текстовом виде (по умолчанию)
- `+` — чтение и запись

---

### 45. Файлы. Текстовые файлы. Основные методы для работы

#### Файл

_Файл_ — поименованное место на носителе данных (внешняя память).

#### Текстовые файлы

_Текстовый файл_ — файл, содержащий текстовые данные.

#### Открытие текстового файла

```py
file = open("path-to-file", mode="rt", encoding="utf-8")
...
file.close()
```

```py
file = open("path-to-file")
...
file.close()
```

```py
with open("path-to-file", "r") as file:
    ...
```

#### Методы работы с текстовыми файлами

- `f.close()`
- `f.read()`
- `f.readline()`
- `f.readlines()`
- `f.write()`
- `f.writelines(lines)`
- `f.truncate(size)`
- `f.seek(offset)`
- `f.tell()`

---

### 46. Файлы. Текстовые файлы. Чтение файла. Запись в файл. Поиск в файле

#### Файл

_Файл_ — поименованное место на носителе данных (внешняя память).

#### Текстовые файлы

_Текстовый файл_ — файл, содержащий текстовые данные.

#### Чтение текстового файла

Чтение полностью:
```py
with open("text.txt", "rt") as file:
    print(file.read())
```

Чтение построчно:
```py
with open("text.txt", "rt") as file:
    for line in file:
        print(line)
```

Чтение посимвольно (не по байтам!):
```py
with open("text.txt", "rt") as file:
    print(file.read(1))
```

#### Запись в текстовый файл

Перезапись файла:
```py
with open("text.txt", "wt") as file:
    file.write(data)
```

Запись в конец
```py
with open("text.txt", "at") as file:
    file.write(data)
```

#### Поиск в файле

А что искать-то?

---

### 47. Файлы. Текстовые файлы. Итерационное чтение содержимого файла

#### Файл

_Файл_ — поименованное место на носителе данных (внешняя память).

#### Текстовые файлы

_Текстовый файл_ — файл, содержащий текстовые данные.

#### Итерационное чтение файла

См. ответ на вопрос 46, кроме метода `file.read()`.

---

### 48. Файлы. Бинарные файлы. Основные методы. Сериализация данных

#### Файл

_Файл_ — поименованное место на носителе данных (внешняя память).

#### Бинарный файл

_Бинарный (двоичный) файл_ — файл, хранящий произвольную последовательность байт.

> Примечание автора: граница между текстовыми и бинарными файлами размыта. Ведь текст тоже хранится как последовательность байт, и любой текстовый файл можно прочитать в бинарном режиме (но не наоборот!). 

#### Открытие бинарного файла

```py
file = open("path-to-file", mode="rb")
...
file.close()
```

```py
file = open("path-to-file", "b")
...
file.close()
```

```py
with open("path-to-file", "rb") as file:
    ...
```

#### Методы бинарных файлов

- `f.buffer`
- `f.flush()`
- `f.readable()`
- `f.truncate()`
- `f.close()`
- `f.isatty()`
- `f.readline()`
- `f.writable()`
- `f.closed`
- `f.line_buffering`
- `f.readlines()`
- `f.write()`
- `f.detach()`
- `f.mode`
- `f.reconfigure()`
- `f.write_through`
- `f.encoding`
- `f.name`
- `f.seek()`
- `f.writelines()`
- `f.errors`
- `f.newlines`
- `f.seekable()`
- `f.fileno()`
- `f.read()`
- `f.tell()`

---

### 49. Файлы. Оператор with. Исключения при работе с файлами

#### Файл

_Файл_ — поименованное место на носителе данных (внешняя память).

#### Оператор with

> От автора: оператор `with` [это немного больше, чем открытие файлов (хабр)](https://habr.com/ru/articles/739326/)

Оператор `with` заменяет собой конструкцию:
```py
file = open("file.txt", "r")
try:
    content = file.read()
    print(content)
finally:
    file.close()
```

На более лаконичную:

```py
with open("file.txt", "r") as file:
    content = file.read()
    print(content)
```

Это нужно, чтобы гарантированно закрыть файл, даже в случае исключения.

#### Исключение при работе с файлами

> От автора: буквально цитата из презентации лекции

Ошибки возможны:
- при открытии файла
- при записи
- и вообще при любых операциях

---

### 50. Типы данных bytes и bytearray. Байтовые строки. Конвертация различных типов в байтовые строки и обратно

#### Типы данных bytes и bytearray, байтовые строки

`bytes` и `bytearray` - классы для представления бинарных данных, "байтовые
строки".

Набор операторов и методов похож на аналогичный у обычных строк.

`bytes` — неизменяемый, `bytearray` — изменяемый

#### Конвертация в байты и обратно

> Примечание автора: в примерах важно помнить про [порядок байтов (хабр)](https://habr.com/ru/articles/233245/)

1. Для чисел — методы `to_bytes` и `from_bytes`:
```py
int.to_bytes(length, byteorder)
int.from_bytes(bytes, byteorder)
```
Пример:
```py
>>> a = 1024
>>> b = a.to_bytes(4, "big")
>>> b
b'\x00\x00\x04\x00'
>>> a = int.from_bytes(b, "big") 
>>> a
1024
```

2. Для строк — методы `encode` и `decode`:
```py
>>> s = "hello!"
>>> b = s.encode("utf-8")
>>> b
b'hello!'
>>> s = b.decode("utf-8")
>>> s
'hello!'
```

3. Модуль `struct`
См. ответ на вопрос 51.

---

### 51. Модуль struct

Формирует упакованные двоичные структуры данных из переменных базовых типов данных и распаковывает их обратно.

Функции:
- `pack(format, v1, v2, ...)`
- `pack_into(format, buffer, offset, v1, v2, ...)`
- `unpack(format, buffer)`
- `unpack_from(format, /, buffer, offset=0)`
- `iter_unpack(format, buffer)`
- `calcsize(format)`

Формат `struct`

<table>
<thead>
    <tr>
        <th>Символ</th>
        <th>Тип в языке Си</th>
        <th>Python тип</th>
        <th>Станд. размер</th>
    </tr>
</thead>
<tbody>
    <tr>
        <td><code>x</code></td>
        <td>байт набивки</td>
        <td>нет значения</td>
        <td></td>
    </tr>
    <tr>
        <td><code>c</code></td>
        <td><code>char</code></td>
        <td>bytes длины 1</td>
        <td>1</td>
    </tr>
    <tr>
        <td><code>b</code></td>
        <td><code>signed&nbsp;char</code></td>
        <td>integer</td>
        <td>1</td>
    </tr>
    <tr>
        <td><code>B</code></td>
        <td><code>unsigned&nbsp;char</code></td>
        <td>integer</td>
        <td>1</td>
    </tr>
    <tr>
        <td><code>?</code></td>
        <td><code>_Bool</code></td>
        <td>bool</td>
        <td>1</td>
    </tr>
    <tr>
        <td><code>h</code></td>
        <td><code>short</code></td>
        <td>integer</td>
        <td>2</td>
    </tr>
    <tr>
        <td><code>H</code></td>
        <td><code>unsigned&nbsp;short</code></td>
        <td>integer</td>
        <td>2</td>
    </tr>
    <tr>
        <td><code>i</code></td>
        <td><code>int</code>
        </td><td>integer</td>
        <td>4</td>
    </tr>
    <tr>
        <td><code>I</code></td>
        <td><code>unsigned&nbsp;int</code></td>
        <td>integer</td>
        <td>4</td>
    </tr>
    <tr>
        <td><code>l</code></td>
        <td><code>long</code></td>
        <td>integer</td>
        <td>4</td>
    </tr>
    <tr>
        <td><code>L</code></td>
        <td><code>unsigned&nbsp;long</code></td>
        <td>integer</td>
        <td>4</td>
    </tr>
    <tr>
        <td><code>q</code></td>
        <td><code>long&nbsp;long</code></td>
        <td>integer</td>
        <td>8</td>
    </tr>
    <tr>
        <td><code>Q</code></td>
        <td><code>unsigned&nbsp;long&nbsp;long</code></td>
        <td>integer</td>
        <td>8</td>
    </tr>
    <tr>
        <td><code>n</code></td>
        <td><code>ssize_t</code></td>
        <td>integer</td>
        <td>зависит</td>
    </tr>
    <tr>
        <td><code>N</code></td>
        <td><code>size_t</code></td>
        <td>integer</td>
        <td>зависит</td>
    </tr>
    <tr>
        <td><code>e</code></td>
        <td>"половинный <code>float</code>"</td>
        <td>float</td>
        <td>2</td>
    </tr>
    <tr>
        <td><code>f</code></td>
        <td><code>float</code></td>
        <td>float</td>
        <td>4</td>
    </tr>
    <tr>
        <td><code>d</code></td>
        <td><code>double</code></td>
        <td>float</td>
        <td>8</td>
    </tr>
    <tr>
        <td><code>s</code></td>
        <td><code>char[]</code></td>
        <td>bytes</td>
        <td>указывается явно</td>
    </tr>
    <tr>
        <td><code>p</code></td>
        <td><code>char[]</code> — строка из Паскаля</td>
        <td>bytes</td><td>указывается явно</td>
    </tr>
</tbody>
</table>

Выравнивание
- `@` — нативный, по умолчанию
- `=` — порядок байт нативный, размер стандартный
- `<` — порядок байт от младшего к старшему (LE), размер стандартный
- `>` — порядок байт от старшего к младшему (BE), размер стандартный
- `!` — "сетевой" (аналог `>`)

---

### 52. Модуль os. Основные функции`

#### Модуль os

`os` — библиотека функций для работы с операционной системой.

#### Основные функции

- `os.name` — возвращает короткое название ОС ("posix", "nt" и т.п.);
- `os.environ()` — словарь с переменными окружения;
- `getenv(key)` — получение значения переменной окружения по ключу;
- `putenv(key, value)` — установка переменных окружения;
- `getlogin()` — логин (имя) текущего пользователя.
- `system(command)` — выполняет команду командной строки,
- `times()` — время выполнения текущего процесса.
- `os.path` — реализует некоторые полезные функции для работы с путями.

---

### 53. *Генераторы

> От автора: "Мы этого не проходили, нам этого не задавали!" 
> Если коротко, это про ключевое слово `yield`.

Так что же такое эти генераторы?
Чтобы это понять вспомним про итераторы и итерируемые объекты. Когда мы с ними работаем, мы можем по одному считывать их объекты.
Например, с помощью цикла `for` можно пройтись по элементам списка.
Список — итерируемый объект, когда мы его создаём, мы создаём и итератор. Это отностися к любому итерируему объекту. <br>

_Генератор_ — тоже итерируемый объект, но его особенность в том, что его можно считать лишь один раз. 
Он не хранится в памяти, и это очень удобно, когда надо воспользоваться чем-то только один раз.

Допустим простой пример: надо сначала получить набор значений целиком, а только потом его вывести.

Как бы это выглядело, если бы мы использовали списки? Для примера возьмём набор из квадратов первых 10 натуральных чисел:
```py
numbers = [i ** 2 for i in range(1, 11)]
for number in numbers:
    print(number, end=" ")
# Out: 1 4 9 16 25 36 49 64 81 100

# При желании мы можем снова вывести этот набор
for number in numbers:
    print(number, end=" ")
# Out: 1 4 9 16 25 36 49 64 81 100
```

Но что если нам не нужно запоминать последовательность, тем самым, забивая память?
Нужно всего лишь использовать генератор, заменив квадратные скобки на круглые:

```py
numbers = (i ** 2 for i in range(1, 11))
for number in numbers:
    print(number, end=" ")
# Out: 1 4 9 16 25 36 49 64 81 100

# При попытке снова вывести набор, ничего не произойдёт, ведь генератор, получает значения "на лету" не храня более одного за раз
for number in numbers:
    print(number, end=" ")
# Out: ничего не выведется
```

> Важно: Генераторы — одноразовые, поэтому если нужно снова получить что-то, то придётся снова писать генератор.

Разобравшись с генераторами перейдём к `yield`.

А с ним всё просто. `yield` заменяет `return` в функции, заставляя её работать как генератор.
То есть, когда вы вызываете функцию с `yield`, код функции не исполняется, она только возвращает объект-генератор, который, в свою очередь,
будет выдавать искомые значения, при итерировании.

Чтобы это понять вернёмся к примеру с квадратами, только на этот раз воспользуемся `yield`:

```py
def squares():
    for i in range(1, 11):
        yield i ** 2

numbers = squares()  # Функция ведь вернула генератор — итерируемый объект, чтобы к нему обращаться нужно присвоить ему имя
for number in numbers:
    print(number)
# Out: 1 4 9 16 25 36 49 64 81 100
```

---

### 54. Модуль numpy. Обработка массивов с использованием данного модуля. Работа с числами и вычислениями

---

### 55. Модуль matplotlib. Построение графиков в декартовой системе координат. Управление областью рисования

---

### 56. Модуль matplotlib. Построение гистограмм и круговых диаграмм

---

### 57. Списки. Сортировка. Сортировка вставками. Сортировка выбором

#### Списки

См. ответ на вопрос №15.

#### Сортировка вставками

```py
def insertion_sort(seq: MutableSequence) -> None:
    for i in range(1, len(seq)):
        key = seq[i]
        j = i-1
        while j >=0 and key < seq[j] :
            seq[j+1] = seq[j]
            j -= 1
        seq[j+1] = key 
```

#### Сортировка выбором

```py
def selection_sort(seq: MutableSequence) -> None:
    n = len(seq)
    for i in range(n-1):
        m = i
        for j in range(i+1, n):
            if seq[j] < seq[m]:
                m = j
        seq[i], seq[m] = seq[m], seq[i]
```

---

### 58. Списки. Сортировка вставками. Метод простых вставок. Метод вставок с бинарным поиском. Вставки с барьером. Метод Шелла

#### Списки

См. ответ на вопрос №15.

#### Метод простых вставок

```py
def insertion_sort(seq: MutableSequence) -> None:
    for i in range(1, len(seq)):
        key = seq[i]
        j = i-1
        while j >=0 and key < seq[j] :
            seq[j+1] = seq[j]
            j -= 1
        seq[j+1] = key 
```

#### Метод вставок с бинарным поиском

```py
def insertion_binary_sort(seq: MutableSequence) -> None:
    for i in range(1, len(seq) - 1):
        key = seq[i]
        lo, hi = 0, i - 1
        while lo < hi:
            mid = lo + (hi - lo) // 2
            if key < seq[mid]:
                hi = mid
            else:
                lo = mid + 1
        for j in range(i, lo + 1, -1):
            seq[j] = seq[j-1]
        seq[lo] = key
```

---

### 59. Списки. Сортировка. Обменные методы сортировки. Сортировка пузырьком. Сортировка пузырьком с флагом. Метод шейкер-сортировки

#### Списки

См. ответ на вопрос №15.

#### Сортировка пузырьком

```py
def bubble_sort(seq: MutableSequence) -> None:
    for i in range(len(seq)):
        for j in range(len(seq)-i-1):
            if seq[j] > seq[j+1]:
                seq[j], seq[j+1] = seq[j+1], seq[j]
```

#### Сортировка пузырьком с флагом

```py
def bubble_with_flag_sort(seq: MutableSequence) -> None:
    for i in range(len(seq)):
        swapped = False
        for j in range(len(seq)-i-1):
            if seq[j] > seq[j+1]:
                seq[j], seq[j+1] = seq[j+1], seq[j]
                swapped = True
        if not swapped:
            break
```

#### Метод шейкер-сортировки

```py
def shaker_sort(seq: MutableSequence) -> None:
    swapped = True
    start = 0
    end = len(seq) - 1
    while swapped: 
        swapped = False
        for i in range(start, end): 
            if seq[i] > seq[i+1]: 
                seq[i], seq[i+1] = seq[i+1], seq[i] 
                swapped = True
        if not swapped: 
            break
        swapped = False
        end -= 1
        for i in range(end - 1, start - 1, -1): 
            if seq[i] > seq[i+1]:
                seq[i], seq[i+1] = seq[i+1], seq[i] 
                swapped = True
        start += 1
```

---

### 60. Списки. Сортировка. Метод быстрой сортировки

#### Списки

См. ответ на вопрос №15.

#### Быстрая сортировка

```py
import random

def quicksort(seq: Sequence) -> Sequence:
   if len(seq) <= 1:
       return seq
   else:
       q = random.choice(seq)
   l_nums = [n for n in seq if n < q]
   e_nums = [q] * seq.count(q)
   b_nums = [n for n in seq if n > q]
   return quicksort(l_nums) + e_nums + quicksort(b_nums)
```
